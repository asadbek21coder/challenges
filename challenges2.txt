
1. Foydalanuvchidan qiymat qabul qiling va uni tipini ekranga chiqaring.

2. Foydalanuvchi son kiritadi, kiritilgan son juft bo'lsa ekranga "juft" aks holda "toq" degan yozuvchi chiqaring.

**3. Foydalanuvchi 2 ta belgi kiritadi. Ulardan bittasi belgi Ikkibchisi son bo'ladi. Siz ekranga kiritilgan belgini kiritilgan songa teng miqdorda ekranga chiqaring.

4. Foydalanuvchi string kiritadi siz uning uzunligini ekranga chiqaring.

5. Foydalanuvchi ikkita string kiritadi. Siz Ikkala string uzunliklarini qo'shib ekranga chiqaring.

6. Foydalanuvchi ikkita son kiritadi. Siz Ikkala sonni bir-biriga bo'lib chiqqan natijani yuqoriga qarab yaxlitlab ekranga chiqaring.

7. Foydalanuvchi kiritgan raqamni int, float, bool tiplarida ekranga chiqaring.

8. Foydalanuvchi son kiritadi, kiritilgan son 80-100 orasida bo`lsa "bahoyingiz a`lo", 60-80 orasida bo`lsa "bahoyingiz yaxshi", 40-60 orasida bo`lsa "bahoyingiz qoniqarli", 0-40 orasida bo`lsa "bahoyingiz qoniqarisiz" degan matnnni chiqaring. 0 dan kichkina son kiritish mumkin bo`lmasligi kerak.

9. Kiritilgan belgi "harf" ekanligini aniqlang.

	Input:     "K"
	Output:  "harf"

	Input:     "$"
	Output:  "harf emas"

10. Foydalanuvchi 5 xonali son kiritadi. Shu sonning raqamlari yig'indisini toping
	
	Input:      65478
	Output:  30 
	
11. Foydalanuvchi 2 xonali son kiritadi. Shu sonning raqamlarini o'rinini almashtirib o'ziga o'zlashtiring.

	Input:      57
	Output:  75

12. Foydalanuvchi 7 xonali son kiritadi. Shu sonni teskari tartibda o'ziga o'zlashtiring, va ekranga chiqaring.

	Input:      1234567
	Output:   7654321

**13. Foydalanuvchi n son kiritadi. Siz esa, 1 dan n gacha bo‘lgan "juft" sonlarni sonini ekranga chiqaring.

14. Foydalanuvchi sekundlarni kiritadi. Siz uning nechchi soat, minut va sekundligini ekranga chiqaring

	Input: 4000
	Output: 1 soat 6 min 40 sek

	Input: 3600
	Output: 1 soat 0 min 0 sek

**15. Foydalanuvchi ixtiyoriy uzunlikdagi son kiritadi, string va arraydan foydalanmasdan sonni teskari yozib bering.

	input : 12345
	output: 54321 


If


	1. yil berilgan(musbat butun son). Berilgan yilda nechta kun borligini aniqlovchi
	programma tuzilsin. Kabisa yilida 366 kun bor, kabisa bo'lmagan yilda 365 kun bor. Kabisa
	yil deb 4 ga karrali yillarga aytiladi. Lekin 100 ga karrali yillar ichida faqat 400 ga karrali
	bo'lganlari kabisa yil hisoblanadi. Masalan 300, 1300 va 1900 kabisa yili emas. 1200 ва
	2000 kabisa yili.

	2. x,y haqiqiy sonlari berilgan. Ularning kichigini sonlar yigʼindisining yarmiga, kattasini
	koʼpaytmasining ikkilanganiga almashtiruvchi programma tuzilsin. Аgar sonlar ten
	bolsa, ozgarishsiz koldirilsin.
________________________________________________________

	3. Ikkita butun son berilgan, Day(kun) va Month(oy). Berilgan sanadan keyingi sanani chiqaruvchi funksiya tuzing. (Kabisa bo'lmagan yil beriladi.)

	4. N natural son berilgan. Shu sonlargacha bo`lgan mukammal sonlarni chiqarib beruvchi funksiya yozing. Mukammal sonlar o'zidan boshqa hamma bo'luvchilarini ying'indisiga teng bo'lgan son. Masalan 6 = 1+2+3, 28=1+2+4+7+14

	5. N butun soni berilgan. berilgan sonni tub yoki tub emasligini aniqlovchi funksiya tuzing.

	
Funksiya
	1. Haqiqiy sonning ishorasini aniqlovchi ishora nomli funksiya hosil qiling. Funktsiya argumenti noldan kichik bolsa -1; noldan katta bolsa 1; nolga teng bolsa 0 kiymat
	kaytarsin. Xaqiqiy a va b sonlari uchun ishora(a) + ishora(b) ifodasi hisoblansin.
	
	2. Kvadrat tenglamaning ildizlar sonini aniqlovchi funksiya hosil qiling. A * x² + B * x + C = 0 koʼrinishidagi tenglama kvadrat tenglama deyiladi. (son noldan farqli)

	3.Doiraning yuzini hisoblovchi funksiya hosil qilin. Bu funksiya yordamida 3 ta doira yuzini hisoblang. Doiraning yuzi S = π R² orqali hisoblanadi. Pi = 3,1415 ni oʼzgarmas
	deb qabul qiling.

	4. Markazi bir nuqtada bolgan, R1 va R2 radiusga yega 2 ta aylananing ustma-ust
	tushmaydigan (keshmaydigan) qismining yuzasini topuvchi RingS nomli funksiya xosil qilin.
	Doiraning yuzini xisoblash formulsidan foydalaning. S = πR². Pi = 3,1415 ni oʼzgarmas deb
	qabul qiling.

	5. Toʼgʼri burchakli uchburchakning katetlari A va B berilganda, uning perimetrini
	hisoblovchi Trianglep nomli funksiya hosil qiling.

	6. А va B sonlari orasidagi sonlar yigʼindisini hisoblovchi SumRange(А, B)
	nomli funksiya hosil qilin. Аgar A > B boʼlsa, funktsiya 0 qiymat qaytaradi. Bu funksiya orqali A dan B gacha va B dan C gacha boʼlgan sonlar yigʼinddisini hisoblang. А, B, S butun sonlar.
_______________________________________________________________

	7. Arifmetik amallarni bajaruvchi Calc(A, B, Op) funksiyasini hosil qiling. A va B haqiqiy
	sonlar. Op oʼzgaruchisi orqali bajariladigan arifmetik amal aniqlanadi. 1 - ayirish, 2 - koʼpaytirish,
	3 - boʼlish, boshqalari qoʼshish. Shu funksiya orqali А va B sonlari uchun N1, N2, N3, N4 amallari badjarilsin. (N1 - N4 butun sonlar)

	8. X va Y butun sonlari berilgan (X va Y noldan farqli). (X, Y) nuqta qaysi chorakda yekanini aniqlovchi Chetvert nomli funksiya xosil siling. Bu funksiya orqali 4 ta nuqtaning choragini aniqlang.

	9. Butun sonning juft - toqligini aniqlovchi Even(K) funksiyasini xosil qilin.
	Funksiya K djuft son bolsa – true, aks xolda false00 kiymat qaytarsin. Bu funksiya orqali 3 ta sonning juft yoki toqligi aniqlansin.

Massiv:

	1. n natural soni va А, B butun sonlari berilgan (n > 2). a[0] = А; a[1] = V; boshqa elementlari o'zidan oldingi barcha elementlari yig'indisiga teng bo'lgan massivni hosil qiling va elementlarini chiqaring.

	2. n ta elementdan tashkil topgan massiv berilgan. Uning elementlarini teskari tartibda	chiqaruvchi programma tuzilsin.

	
	3. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari orasidan toqlarini indexlari o'sish tartibida chiqaruvchi va ularning sonini chiqaruvchi programma tuzilsin.
	Massiv elementlar: 4 5 7 8 69
	Natija: 5 7 9 toqlar soni = 3

	4. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari orasidan juftlarini indexlari kamayish tartibida chiqaruvchi va ularning sonini chiqaruvchi programma tuzilsin.
	Elementar massiva: 4 5 7 8 69
	Natiya: 6 8 4 yuftlyar soni = 3
	
	5. n ta elementdan tashkil topgan massiv berilgan. Dastlab massiv elementlari orasidan juftlarini indekslari o'sish tartibida chiqaruvchi, keyin massiv elementlari orasidan toqlarini indekslari kamayish tartibida chiqaruvchi programma tuzilsin.
	Massiv elementlari: 4 5 7 8 69
	Natija: 48 6 975

	6. n ta elementdan tashkil topgan massiv va K butun soni berilgan (1 <= K < n). Massiv elementlari orasidan indexi K ga karralilarini chiqaruvchi programma tuzilsin. Аk, А2k, А3k, ....  Shart operatorlari ishlatilmasin.
	
	7. n ta elementdan tashkil topgan massiv berilgan (n yuft son). Massiv elementlari orasidan quyidagilarini chiqaruvchi programma tuzilsin. A[0], A[2], A[4], ... Shart operatorlari ishlatilmasin.
__________________________________________________________

	8. n ta elementdan tashkil topgan massiv berilgan. Massiv oxirgi elementidan kichkina bo'lgan birinchi elementni chiqaruvchi programma tuzilsin. Agar bunday  element  bo'lmasa, nol chiqarilsin. 

	9. n ta elementdan tashkil topgan massiv berilgan. Massiv oxirgi elementidan kichkina va dastlabki elementidan katta bo'lgan oxirgi element indexini chiqaruvchi programma
	tuzilsin. Agar bunday  element  bo'lmasa, nol chiqarilsin. (a[0] <a[k] <a[n-1])

	10. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K <= L <N). Massivning K va L indexlari orasidagi elementlari yig'indisini chiqaruvchi programma tuzilsin.

	11. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K <= L < N). Massivning K va L indexlari orasidagi elementlarining o'rta arifmetigini chiqaruvchi programma tuzilsin.

	12. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K <= L < N). Massivning K va L indexlari orasidagi elementlaridan tashqari elementlari yig'indisini chiqaruvchi programma tuzilsin.

	13. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K <= L < N). Massivning K va L indexlari orasidagi elementlaridan tashqari elementlarining o'rta arifmetigini chiqaruvchi programma tuzilsin.
	
	14. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari arifmetik progressiyani tashkil qilsa, ayirmani aksholda nolni chiqaruvchi programma tuzilsin.
	
	15. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari geometrik progressiyani tashkil qilsa, maxrajni aksholda nolni chiqaruvchi programma tuzilsin.
	
	16. n ta elementdan tashkil topgan massiv berilgan. Massivda juft va toq elementlar ketma-ket kelishini tekshiruvchi programma tuzilsin. Ketma-ketlik bajarilsa nol chiqarilsin. Аks xolda ketma-ketlikni buzgan birinchi element indeksi chiqarilsin.



	18. n ta elementdan tashkil topgan massiv berilgan. Massiv oxirgi elementidan kichkina
bo'lgan birinchi elementni chiqaruvchi programma tuzilsin. Element agar bunday element bo'lmasa, nol
chiqarilsin.

	19. n ta elementdan tashkil topgan massiv berilgan. Massiv oxirgi elementidan kichkina
va dastlabki elementidan katta bo'lgan oxirgi element indexini chiqaruvchi programma
tuzilsin. Agar  bunday element bo'lmasa, nol chikarilsin. (a[0] <a[k] <a[n-1])

	20. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K
<= L <N). Massivning K va L indexlari orasidagi elementlari yig'indisini chiqaruvchi programma
tuzilsin.

	21. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K
<= L <N). Massivning K va L indexlari orasidagi elementlarining oʻrta arifmetigini chiqaruvchi
programma tuzilsin.

	22. N ta elementdan tashkil topgan massiv va K, l butun sonlari berilgan. (0 <= K
<= L < N). Massivning K va L indexlari orasidagi elementlaridan tashqari elementlarining o'rta
arifmetigini chiqaruvchi programma tuzilsin.

	23. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari arifmetik
progressiyani tashkil qilsa, ayirmani aks holda nolni chiqaruvchi programma tuzilsin.

	25. n ta elementdan tashkil topgan massiv berilgan. Massiv elementlari geometrik
progressiyani tashkil qilsa, maxrajni aksholda nolni chiqaruvchi programma tuzilsin.

	26. n ta elementdan tashkil topgan massiv berilgan. Massivda juft va toq elementlar
ketma-ket kelishini tekshiruvchi programma tuzilsin. Ketma-ketlik badjarilsa nol chikarilsin.
Аks xolda ketma-ketlikni buzgan birinchi element indeksi chiqarilsin.

	27. 



Student Grade Tracker:
Create a struct called Student with fields name and grades, where grades is a slice of integers. Implement methods to add grades, calculate the average grade, and display the student's information.
go
Copy code
package main

import "fmt"

type Student struct {
	name   string
	grades []int
}

func (s *Student) AddGrade(grade int) {
	s.grades = append(s.grades, grade)
}

func (s *Student) CalculateAverageGrade() float64 {
	sum := 0
	for _, grade := range s.grades {
		sum += grade
	}
	return float64(sum) / float64(len(s.grades))
}

func (s *Student) DisplayInformation() {
	fmt.Println("Name:", s.name)
	fmt.Println("Grades:", s.grades)
	fmt.Println("Average Grade:", s.CalculateAverageGrade())
}

func main() {
	student := Student{name: "John Doe"}
	student.AddGrade(90)
	student.AddGrade(85)
	student.AddGrade(92)
	student.DisplayInformation()
}
Output:

yaml
Copy code
Name: John Doe
Grades: [90 85 92]
Average Grade: 89
Bank Account:
Create a struct called BankAccount with fields accountNumber, balance, and ownerName. Implement methods to deposit, withdraw, and display the account details.
go
Copy code
package main

import "fmt"

type BankAccount struct {
	accountNumber string
	balance       float64
	ownerName     string
}

func (b *BankAccount) Deposit(amount float64) {
	b.balance += amount
}

func (b *BankAccount) Withdraw(amount float64) {
	if amount <= b.balance {
		b.balance -= amount
	} else {
		fmt.Println("Insufficient funds.")
	}
}

func (b *BankAccount) DisplayAccountDetails() {
	fmt.Println("Account Number:", b.accountNumber)
	fmt.Println("Owner Name:", b.ownerName)
	fmt.Println("Balance:", b.balance)
}

func main() {
	account := BankAccount{
		accountNumber: "1234567890",
		balance:       1000.0,
		ownerName:     "John Doe",
	}
	account.Deposit(500.0)
	account.Withdraw(200.0)
	account.DisplayAccountDetails()
}
Output:

yaml
Copy code
Account Number: 1234567890
Owner Name: John Doe
Balance: 1300
These challenges demonstrate basic OOP implementation in Go. They involve creating structs, defining methods on those structs, and utilizing the methods to perform actions or retrieve information. Practice these challenges to gain a solid understanding of OOP concepts in Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Shape:
Create a struct called Shape with a method to calculate the area. Implement derived structs Rectangle and Circle that inherit from Shape and override the CalculateArea() method.
go
Copy code
package main

import (
	"fmt"
	"math"
)

type Shape interface {
	CalculateArea() float64
}

type Rectangle struct {
	width  float64
	height float64
}

func (r Rectangle) CalculateArea() float64 {
	return r.width * r.height
}

type Circle struct {
	radius float64
}

func (c Circle) CalculateArea() float64 {
	return math.Pi * c.radius * c.radius
}

func main() {
	rectangle := Rectangle{width: 5.0, height: 3.0}
	circle := Circle{radius: 2.5}

	shapes := []Shape{rectangle, circle}

	for _, shape := range shapes {
		area := shape.CalculateArea()
		fmt.Printf("Area: %.2f\n", area)
	}
}
Output:

makefile
Copy code
Area: 15.00
Area: 19.63
Book Catalog:
Create a struct called Book with fields title, author, and year. Implement a method to display the book details.
go
Copy code
package main

import "fmt"

type Book struct {
	title  string
	author string
	year   int
}

func (b Book) DisplayDetails() {
	fmt.Println("Title:", b.title)
	fmt.Println("Author:", b.author)
	fmt.Println("Year:", b.year)
}

func main() {
	book := Book{
		title:  "The Great Gatsby",
		author: "F. Scott Fitzgerald",
			year:   1925,
	}
	book.DisplayDetails()
}
Output:

yaml
Copy code
Title: The Great Gatsby
Author: F. Scott Fitzgerald
Year: 1925
Contact List:
Create a struct called Contact with fields name and phone. Implement a method to display the contact information.
go
Copy code
package main

import "fmt"

type Contact struct {
	name  string
	phone string
}

func (c Contact) DisplayInfo() {
	fmt.Println("Name:", c.name)
	fmt.Println("Phone:", c.phone)
}

func main() {
	contact := Contact{name: "John Doe", phone: "123-456-7890"}
	contact.DisplayInfo()
}
Output:

makefile
Copy code
Name: John Doe
Phone: 123-456-7890
These challenges focus on applying OOP principles like inheritance, method overriding, and encapsulation. By practicing these challenges, you'll strengthen your understanding of OOP concepts in Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Car Rental System:
Create a struct called Car with fields make, model, and rented (a boolean indicating whether the car is currently rented). Implement methods to rent and return a car.
go
Copy code
package main

import "fmt"

type Car struct {
	make   string
	model  string
	rented bool
}

func (c *Car) Rent() {
	if c.rented {
		fmt.Println("Car is already rented.")
	} else {
		c.rented = true
		fmt.Println("Car rented successfully.")
	}
}

func (c *Car) Return() {
	if c.rented {
		c.rented = false
		fmt.Println("Car returned successfully.")
	} else {
		fmt.Println("Car is not rented.")
	}
}

func main() {
	car := Car{make: "Toyota", model: "Camry", rented: false}
	car.Rent()   // Car rented successfully.
	car.Rent()   // Car is already rented.
	car.Return() // Car returned successfully.
	car.Return() // Car is not rented.
}
Output:

csharp
Copy code
Car rented successfully.
Car is already rented.
Car returned successfully.
Car is not rented.
Email Validator:
Create a struct called Email with a field address. Implement a method to validate if an email address is valid based on a simple pattern check.
go
Copy code
package main

import (
	"fmt"
	"regexp"
)

type Email struct {
	address string
}

func (e Email) Validate() bool {
	pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
	valid, _ := regexp.MatchString(pattern, e.address)
	return valid
}

func main() {
	email := Email{address: "john.doe@example.com"}
	isValid := email.Validate()
	fmt.Println("Email is valid:", isValid)
}
Output:

csharp
Copy code
Email is valid: true
Bank Transaction:
Create a struct called BankAccount with fields accountNumber, balance, and ownerName. Implement methods to deposit, withdraw, and display the account details.
go
Copy code
package main

import "fmt"

type BankAccount struct {
	accountNumber string
	balance       float64
	ownerName     string
}

func (b *BankAccount) Deposit(amount float64) {
	b.balance += amount
	fmt.Println("Deposit successful.")
}

func (b *BankAccount) Withdraw(amount float64) {
	if amount > b.balance {
		fmt.Println("Insufficient balance.")
	} else {
		b.balance -= amount
		fmt.Println("Withdrawal successful.")
	}
}

func (b *BankAccount) DisplayAccountDetails() {
	fmt.Println("Account Number:", b.accountNumber)
	fmt.Println("Owner Name:", b.ownerName)
	fmt.Println("Balance:", b.balance)
}

func main() {
	account := BankAccount{
		accountNumber: "1234567890",
		balance:       1000.0,
		ownerName:     "John Doe",
	}
	account.Deposit(500.0)
	account.Withdraw(200.0)
	account.DisplayAccountDetails()
}
Output:

yaml
Copy code
Deposit successful.
Withdrawal successful.
Account Number: 1234567890
Owner Name: John Doe
Balance: 1300
These challenges provide opportunities to practice OOP principles like encapsulation, data validation, and behavior implementation in Go. Keep practicing to enhance your understanding and proficiency in OOP with Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Employee Management System:
Create a struct called Employee with fields name, id, and position. Implement methods to set and display employee details.
go
Copy code
package main

import "fmt"

type Employee struct {
	name     string
	id       int
	position string
}

func (e *Employee) SetDetails(name string, id int, position string) {
	e.name = name
	e.id = id
	e.position = position
}

func (e Employee) DisplayDetails() {
	fmt.Println("Name:", e.name)
	fmt.Println("ID:", e.id)
	fmt.Println("Position:", e.position)
}

func main() {
	employee := Employee{}
	employee.SetDetails("John Doe", 12345, "Manager")
	employee.DisplayDetails()
}
Output:

makefile
Copy code
Name: John Doe
ID: 12345
Position: Manager
Product Inventory System:
Create a struct called Product with fields name, price, and quantity. Implement methods to update the quantity, calculate the total value, and display product information.
go
Copy code
package main

import "fmt"

type Product struct {
	name     string
	price    float64
	quantity int
}

func (p *Product) UpdateQuantity(quantity int) {
	p.quantity += quantity
}

func (p Product) CalculateTotalValue() float64 {
	return p.price * float64(p.quantity)
}

func (p Product) DisplayInformation() {
	fmt.Println("Name:", p.name)
	fmt.Println("Price:", p.price)
	fmt.Println("Quantity:", p.quantity)
	fmt.Println("Total Value:", p.CalculateTotalValue())
}

func main() {
	product := Product{
		name:     "iPhone",
		price:    999.99,
		quantity: 5,
	}
	product.UpdateQuantity(2)
	product.DisplayInformation()
}
Output:

yaml
Copy code
Name: iPhone
Price: 999.99
Quantity: 7
Total Value: 6999.93
These challenges provide opportunities to practice OOP principles like data manipulation, method invocation, and information display in Go. Keep practicing to enhance your understanding and proficiency in OOP with Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Rectangle Geometry:
Create a struct called Rectangle with fields length and width. Implement methods to calculate the area and perimeter of the rectangle.
go
Copy code
package main

import "fmt"

type Rectangle struct {
	length float64
	width  float64
}

func (r Rectangle) CalculateArea() float64 {
	return r.length * r.width
}

func (r Rectangle) CalculatePerimeter() float64 {
	return 2 * (r.length + r.width)
}

func main() {
	rectangle := Rectangle{length: 5.0, width: 3.0}
	area := rectangle.CalculateArea()
	perimeter := rectangle.CalculatePerimeter()

	fmt.Println("Area:", area)
	fmt.Println("Perimeter:", perimeter)
}
Output:

makefile
Copy code
Area: 15
Perimeter: 16
Email Client:
Create a struct called Email with fields sender, recipient, and message. Implement a method to send an email and display the email details.
go
Copy code
package main

import "fmt"

type Email struct {
	sender    string
	recipient string
	message   string
}

func (e Email) SendEmail() {
	fmt.Println("Sending email...")
	fmt.Println("From:", e.sender)
	fmt.Println("To:", e.recipient)
	fmt.Println("Message:", e.message)
	fmt.Println("Email sent successfully.")
}

func main() {
	email := Email{
		sender:    "sender@example.com",
		recipient: "recipient@example.com",
		message:   "Hello, this is an email.",
	}
	email.SendEmail()
}
Output:

kotlin
Copy code
Sending email...
From: sender@example.com
To: recipient@example.com
Message: Hello, this is an email.
Email sent successfully.
Bank Customer:
Create a struct called Customer with fields name and accountBalance. Implement a method to display the customer's information.
go
Copy code
package main

import "fmt"

type Customer struct {
	name           string
	accountBalance float64
}

func (c Customer) DisplayInfo() {
	fmt.Println("Name:", c.name)
	fmt.Println("Account Balance:", c.accountBalance)
}

func main() {
	customer := Customer{
		name:           "John Doe",
		accountBalance: 1000.0,
	}
	customer.DisplayInfo()
}
Output:

yaml
Copy code
Name: John Doe
Account Balance: 1000
These challenges provide opportunities to practice OOP principles like data manipulation, method invocation, and information display in Go. Keep practicing to enhance your understanding and proficiency in OOP with Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Student Record:
Create a struct called Student with fields name, age, and grade. Implement a method to display the student's information.
go
Copy code
package main

import "fmt"

type Student struct {
	name  string
	age   int
	grade int
}

func (s Student) DisplayInfo() {
	fmt.Println("Name:", s.name)
	fmt.Println("Age:", s.age)
	fmt.Println("Grade:", s.grade)
}

func main() {
	student := Student{
		name:  "John Doe",
		age:   16,
		grade: 10,
	}
	student.DisplayInfo()
}
Output:

makefile
Copy code
Name: John Doe
Age: 16
Grade: 10
Bank Account:
Create a struct called BankAccount with fields accountNumber and balance. Implement methods to deposit and withdraw money from the account.
go
Copy code
package main

import "fmt"

type BankAccount struct {
	accountNumber string
	balance       float64
}

func (b *BankAccount) Deposit(amount float64) {
	b.balance += amount
	fmt.Println("Deposit successful.")
}

func (b *BankAccount) Withdraw(amount float64) {
	if amount > b.balance {
		fmt.Println("Insufficient balance.")
	} else {
		b.balance -= amount
		fmt.Println("Withdrawal successful.")
	}
}

func main() {
	account := BankAccount{
		accountNumber: "1234567890",
		balance:       1000.0,
	}
	account.Deposit(500.0)
	account.Withdraw(200.0)
	fmt.Println("Account Balance:", account.balance)
}
Output:

yaml
Copy code
Deposit successful.
Withdrawal successful.
Account Balance: 1300
Vehicle:
Create a struct called Vehicle with fields make and model. Implement a method to display the vehicle details.
go
Copy code
package main

import "fmt"

type Vehicle struct {
	make  string
	model string
}

func (v Vehicle) DisplayDetails() {
	fmt.Println("Make:", v.make)
	fmt.Println("Model:", v.model)
}

func main() {
	vehicle := Vehicle{
		make:  "Toyota",
		model: "Camry",
	}
	vehicle.DisplayDetails()
}
Output:

makefile
Copy code
Make: Toyota
Model: Camry
These challenges provide opportunities to practice OOP principles like data manipulation, method invocation, and information display in Go. Keep practicing to enhance your understanding and proficiency in OOP with Go.





User
continue
ChatGPT
Certainly! Here are a few more easy-level challenges for learning OOP implementation in Go along with their solutions:

Product Catalog:
Create a struct called Product with fields name, price, and quantity. Implement a method to display the product details.
go
Copy code
package main

import "fmt"

type Product struct {
	name     string
	price    float64
	quantity int
}

func (p Product) DisplayDetails() {
	fmt.Println("Name:", p.name)
	fmt.Println("Price:", p.price)
	fmt.Println("Quantity:", p.quantity)
}

func main() {
	product := Product{
		name:     "iPhone",
		price:    999.99,
		quantity: 5,
	}
	product.DisplayDetails()
}
Output:

makefile
Copy code
Name: iPhone
Price: 999.99
Quantity: 5
Circle Geometry:
Create a struct called Circle with a field radius. Implement methods to calculate the area and circumference of the circle.
go
Copy code
package main

import (
	"fmt"
	"math"
)

type Circle struct {
	radius float64
}

func (c Circle) CalculateArea() float64 {
	return math.Pi * c.radius * c.radius
}

func (c Circle) CalculateCircumference() float64 {
	return 2 * math.Pi * c.radius
}

func main() {
	circle := Circle{radius: 5.0}
	area := circle.CalculateArea()
	circumference := circle.CalculateCircumference()

	fmt.Println("Area:", area)
	fmt.Println("Circumference:", circumference)
}
Output:

makefile
Copy code
Area: 78.53981633974483
Circumference: 31.41592653589793
Book Library:
Create a struct called Book with fields title, author, and year. Implement a method to display the book details.
go
Copy code
package main

import "fmt"

type Book struct {
	title  string
	author string
	year   int
}

func (b Book) DisplayDetails() {
	fmt.Println("Title:", b.title)
	fmt.Println("Author:", b.author)
	fmt.Println("Year:", b.year)
}

func main() {
	book := Book{
		title:  "The Great Gatsby",
		author: "F. Scott Fitzgerald",
		year:   1925,
	}
	book.DisplayDetails()
}
Output:

yaml
Copy code
Title: The Great Gatsby
Author: F. Scott Fitzgerald
Year: 1925
These challenges provide opportunities to practice OOP principles like data manipulation, method invocation, and information display in Go. Keep practicing to enhance your understanding and proficiency in OOP with Go.






Certainly! Here are 5 easy-level coding challenges for learning Object-Oriented Programming (OOP) implementation in Go:

Bank Account:
Create a struct called BankAccount with fields accountNumber and balance. Implement methods for depositing and withdrawing money from the account.
Solution:

go
Copy code
package main

import "fmt"

type BankAccount struct {
    accountNumber string
    balance       float64
}

func (ba *BankAccount) Deposit(amount float64) {
    ba.balance += amount
    fmt.Printf("Deposited $%.2f\n", amount)
}

func (ba *BankAccount) Withdraw(amount float64) {
    if ba.balance >= amount {
        ba.balance -= amount
        fmt.Printf("Withdrawn $%.2f\n", amount)
    } else {
        fmt.Println("Insufficient balance")
    }
}

func main() {
    account := BankAccount{accountNumber: "1234567890", balance: 1000.00}
    fmt.Println("Initial balance:", account.balance)
    account.Deposit(500.00)
    account.Withdraw(200.00)
    account.Withdraw(1500.00)
    fmt.Println("Remaining balance:", account.balance)
}
Rectangle:
Create a struct called Rectangle with fields width and height. Implement a method to calculate the area of the rectangle.
Solution:

go
Copy code
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) Area() float64 {
    return r.width * r.height
}

func main() {
    rectangle := Rectangle{width: 4.5, height: 6.2}
    area := rectangle.Area()
    fmt.Println("Area of rectangle:", area)
}
Employee:
Create a struct called Employee with fields name, salary, and joiningYear. Implement a method to calculate the current year's salary based on a given percentage increase.
Solution:

go
Copy code
package main

import (
    "fmt"
    "time"
)

type Employee struct {
    name        string
    salary      float64
    joiningYear int
}

func (e Employee) CurrentYearSalary(percentageIncrease float64) float64 {
    currentYear := time.Now().Year()
    yearsOfService := currentYear - e.joiningYear
    return e.salary + (e.salary * percentageIncrease * float64(yearsOfService))
}

func main() {
    employee := Employee{name: "Alice", salary: 5000, joiningYear: 2010}
    currentYearSalary := employee.CurrentYearSalary(0.05)
    fmt.Printf("Current Year Salary for %s: $%.2f\n", employee.name, currentYearSalary)
}
Car:
Create a struct called Car with fields make, model, and year. Implement a method to display the details of the car.
Solution:

go
Copy code
package main

import "fmt"

type Car struct {
    make  string
    model string
    year  int
}

func (c Car) DisplayDetails() {
    fmt.Printf("Make: %s\nModel: %s\nYear: %d\n", c.make, c.model, c.year)
}

func main() {
    car := Car{make: "Toyota", model: "Corolla", year: 2020}
    car.DisplayDetails()
}
Student:
Create a struct called Student with fields name, age, and major. Implement a method to display the student's information.
Solution:

go
Copy code
package main

import "fmt"





User
next
ChatGPT
Certainly! Here are the next 5 easy-level coding challenges for learning OOP implementation in Go:

Dog:
Create a struct called Dog with fields name, breed, and age. Implement a method to make the dog bark.
Solution:

go
Copy code
package main

import "fmt"

type Dog struct {
    name  string
    breed string
    age   int
}

func (d Dog) Bark() {
    fmt.Println(d.name, "says woof!")
}

func main() {
    dog := Dog{name: "Max", breed: "Labrador", age: 3}
    dog.Bark()
}
Book:
Create a struct called Book with fields title, author, and year. Implement a method to display the book's information.
Solution:

go
Copy code
package main

import "fmt"

type Book struct {
    title  string
    author string
    year   int
}

func (b Book) DisplayInfo() {
    fmt.Printf("Title: %s\nAuthor: %s\nYear: %d\n", b.title, b.author, b.year)
}

func main() {
    book := Book{title: "The Great Gatsby", author: "F. Scott Fitzgerald", year: 1925}
    book.DisplayInfo()
}
Point:
Create a struct called Point with fields x and y. Implement a method to calculate the distance between two points.
Solution:

go
Copy code
package main

import (
    "fmt"
    "math"
)

type Point struct {
    x float64
    y float64
}

func (p Point) DistanceTo(other Point) float64 {
    deltaX := other.x - p.x
    deltaY := other.y - p.y
    return math.Sqrt(deltaX*deltaX + deltaY*deltaY)
}

func main() {
    point1 := Point{x: 1.0, y: 2.0}
    point2 := Point{x: 4.0, y: 6.0}
    distance := point1.DistanceTo(point2)
    fmt.Println("Distance between points:", distance)
}
Triangle:
Create a struct called Triangle with fields base and height. Implement a method to calculate the area of the triangle.
Solution:

go
Copy code
package main

import "fmt"

type Triangle struct {
    base   float64
    height float64
}

func (t Triangle) Area() float64 {
    return 0.5 * t.base * t.height
}

func main() {
    triangle := Triangle{base: 5.0, height: 3.0}
    area := triangle.Area()
    fmt.Println("Area of triangle:", area)
}
Mobile Phone:
Create a struct called MobilePhone with fields brand, model, and price. Implement a method to display the phone's details.
Solution:

go
Copy code
package main

import "fmt"

type MobilePhone struct {
    brand string
    model string
    price float64
}

func (mp MobilePhone) DisplayDetails() {
    fmt.Printf("Brand: %s\nModel: %s\nPrice: $%.2f\n", mp.brand, mp.model, mp.price)
}

func main() {
    phone := MobilePhone{brand: "Samsung", model: "Galaxy S20", price: 999.99}
    phone.DisplayDetails()
}
These coding challenges will help you practice implementing OOP concepts in Go. Have fun exploring the world of OOP with Go!





User
next
ChatGPT

2 / 2

Certainly! Here are the next 5 easy-level coding challenges for learning Go syntax and structs:

Temperature Conversion:
Write a program that converts a temperature from Fahrenheit to Celsius. Create a struct called Temperature with fields fahrenheit and celsius. Implement a method to convert the temperature.
Solution:

go
Copy code
package main

import "fmt"

type Temperature struct {
    fahrenheit float64
    celsius    float64
}

func (t *Temperature) Convert() {
    t.celsius = (t.fahrenheit - 32) * 5 / 9
}

func main() {
    temperature := Temperature{fahrenheit: 75}
    temperature.Convert()
    fmt.Printf("Fahrenheit: %.2f\nCelsius: %.2f\n", temperature.fahrenheit, temperature.celsius)
}
Student Grade Average:
Create a struct called Student with fields name and grades, where grades is a slice of integers. Implement a method to calculate and print the average grade of a student.
Solution:

go
Copy code
package main

import "fmt"

type Student struct {
    name   string
    grades []int
}

func (s *Student) CalculateAverage() {
    total := 0
    for _, grade := range s.grades {
        total += grade
    }
    average := float64(total) / float64(len(s.grades))
    fmt.Printf("Average grade for %s: %.2f\n", s.name, average)
}

func main() {
    student := Student{
        name:   "Alice",
        grades: []int{85, 92, 78, 90},
    }
    student.CalculateAverage()
}
Rectangle Area:
Create a struct called Rectangle with fields width and height. Implement a method to calculate and return the area of a rectangle.
Solution:

go
Copy code
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) CalculateArea() float64 {
    return r.width * r.height
}

func main() {
    rectangle := Rectangle{width: 4.5, height: 6.2}
    area := rectangle.CalculateArea()
    fmt.Println("Area of rectangle:", area)
}
Employee Details:
Create a struct called Employee with fields name, age, and designation. Implement a method to display the details of an employee.
Solution:

go
Copy code
package main

import "fmt"

type Employee struct {
    name        string
    age         int
    designation string
}

func (e Employee) DisplayDetails() {
    fmt.Printf("Name: %s\nAge: %d\nDesignation: %s\n", e.name, e.age, e.designation)
}

func main() {
    employee := Employee{name: "Alice", age: 30, designation: "Manager"}
    employee.DisplayDetails()
}
Circle Area and Circumference:
Create a struct called Circle with a field radius. Implement methods to calculate and print the area and circumference of a circle.
Solution:

go
Copy code
package main

import (
    "fmt"
    "math"
)

type Circle struct {
    radius float64
}

func (c Circle) CalculateArea() float64 {
    return math.Pi * c.radius * c.radius
}

func (c Circle) CalculateCircumference() float64 {
    return 2 * math.Pi * c.radius
}

func main() {
    circle := Circle{radius: 3.5}
    area := circle.CalculateArea()
    circumference := circle.CalculateCircumference()
    fmt.Println("Area of circle:", area)
    fmt.Println("Circumference of circle:", circumference)
}
These coding challenges will help you practice Go syntax and struct usage. Have fun learning Go!





User
next
ChatGPT
Certainly! Here are the next 5 easy-level coding challenges for learning Go syntax and structs:

User Registration:
Create a struct called User with fields username and password. Implement a method to validate if a user's password meets certain criteria (e.g., minimum length).
Solution:

go
Copy code
package main

import "fmt"

type User struct {
    username string
    password string
}

func (u User) ValidatePassword() bool {
    minLength := 8
    return len(u.password) >= minLength
}

func main() {
    user := User{username: "johnDoe", password: "password123"}
    isValid := user.ValidatePassword()
    fmt.Println("Password is valid:", isValid)
}
Employee Salary Calculation:
Create a struct called Employee with fields name, hoursWorked, and hourlyRate. Implement a method to calculate the salary of an employee based on hours worked and hourly rate.
Solution:

go
Copy code
package main

import "fmt"

type Employee struct {
    name        string
    hoursWorked int
    hourlyRate  float64
}

func (e Employee) CalculateSalary() float64 {
    return float64(e.hoursWorked) * e.hourlyRate
}

func main() {
    employee := Employee{name: "Alice", hoursWorked: 40, hourlyRate: 15.0}
    salary := employee.CalculateSalary()
    fmt.Println("Salary of", employee.name, "is $", salary)
}
Product Information:
Create a struct called Product with fields name, price, and quantity. Implement a method to display the information of a product.
Solution:

go
Copy code
package main

import "fmt"

type Product struct {
    name     string
    price    float64
    quantity int
}

func (p Product) DisplayInfo() {
    fmt.Printf("Name: %s\nPrice: $%.2f\nQuantity: %d\n", p.name, p.price, p.quantity)
}

func main() {
    product := Product{name: "Phone", price: 999.99, quantity: 5}
    product.DisplayInfo()
}
Point Distance Calculation:
Create a struct called Point with fields x and y. Implement a method to calculate the distance between two points.
Solution:

go
Copy code
package main

import (
    "fmt"
    "math"
)

type Point struct {
    x float64
    y float64
}

func (p Point) CalculateDistance(other Point) float64 {
    deltaX := other.x - p.x
    deltaY := other.y - p.y
    return math.Sqrt(deltaX*deltaX + deltaY*deltaY)
}

func main() {
    point1 := Point{x: 1.0, y: 2.0}
    point2 := Point{x: 4.0, y: 6.0}
    distance := point1.CalculateDistance(point2)
    fmt.Println("Distance between points:", distance)
}
Email Validation:
Create a struct called Email with a field address. Implement a method to validate if an email address is valid based on a simple pattern check.
Solution:

go
Copy code
package main

import (
    "fmt"
    "regexp"
)

type Email struct {
    address string
}

func (e Email) Validate() bool {
    pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
    valid, _ := regexp.MatchString(pattern, e.address)
    return valid
}

func main() {


Binary Tree Traversal:
Create a struct called TreeNode with fields value, left, and right. Implement methods for performing pre-order, in-order, and post-order traversals of a binary tree.
Solution:

go
Copy code
package main

import "fmt"

type TreeNode struct {
    value       int
    left, right *TreeNode
}

func (node *TreeNode) PreOrder() {
    if node != nil {
        fmt.Printf("%d ", node.value)
        node.left.PreOrder()
        node.right.PreOrder()
    }
}

func (node *TreeNode) InOrder() {
    if node != nil {
        node.left.InOrder()
        fmt.Printf("%d ", node.value)
        node.right.InOrder()
    }
}

func (node *TreeNode) PostOrder() {
    if node != nil {
        node.left.PostOrder()
        node.right.PostOrder()
        fmt.Printf("%d ", node.value)
    }
}

func main() {
    tree := &TreeNode{
        value: 1,
        left: &TreeNode{
            value: 2,
            left:  &TreeNode{value: 4},
            right: nil,
        },
        right: &TreeNode{
            value: 3,
            left:  nil,
            right: &TreeNode{value: 5},
        },
    }

    fmt.Println("Pre-order Traversal:")
    tree.PreOrder()
    fmt.Println("\n\nIn-order Traversal:")
    tree.InOrder()
    fmt.Println("\n\nPost-order Traversal:")
    tree.PostOrder()
}
Stack Implementation:
Implement a stack data structure using a struct and methods for push, pop, and peek operations.
Solution:

go
Copy code
package main

import "fmt"

type Stack struct {
    items []int
}

func (stack *Stack) Push(item int) {
    stack.items = append(stack.items, item)
}

func (stack *Stack) Pop() int {
    if len(stack.items) == 0 {
        panic("Stack is empty")
    }
    item := stack.items[len(stack.items)-1]
    stack.items = stack.items[:len(stack.items)-1]
    return item
}

func (stack *Stack) Peek() int {
    if len(stack.items) == 0 {
        panic("Stack is empty")
    }
    return stack.items[len(stack.items)-1]
}

func main() {
    stack := Stack{}
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)

    fmt.Println("Stack:", stack.items)
    fmt.Println("Pop:", stack.Pop())
    fmt.Println("Peek:", stack.Peek())
    fmt.Println("Stack after operations:", stack.items)
}
Linked List Implementation:
Implement a singly linked list data structure using a struct and methods for adding nodes at the front, at the end, and printing the list.
Solution:

go
Copy code
package main

import "fmt"

type ListNode struct {
    value int
    next  *ListNode
}

type LinkedList struct {
    head *ListNode
}

func (list *LinkedList) AddFront(value int) {
    newNode := &ListNode{value: value}

    if list.head == nil {
        list.head = newNode
    } else {
        newNode.next = list.head
        list.head = newNode
    }
}

func (list *LinkedList) AddEnd(value int) {
    newNode := &ListNode{value: value}

    if list.head == nil {
        list.head = newNode
    } else {
        current := list.head
        for current.next != nil {
            current = current.next
        }




User
10 easy level coding challenges for learning golang  structs with answers
ChatGPT
Certainly! Here are 10 easy-level coding challenges for learning Go syntax and structs, along with their solutions:

Rectangle Area:
Create a struct called Rectangle with fields width and height. Write a program that calculates and prints the area of a rectangle.
Solution:

go
Copy code
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func main() {
    rectangle := Rectangle{width: 4.5, height: 6.2}
    area := rectangle.width * rectangle.height
    fmt.Println("Area of rectangle:", area)
}
Circle Area:
Create a struct called Circle with a field radius. Write a program that calculates and prints the area of a circle.
Solution:

go
Copy code
package main

import (
    "fmt"
    "math"
)

type Circle struct {
    radius float64
}

func main() {
    circle := Circle{radius: 3.5}
    area := math.Pi * circle.radius * circle.radius
    fmt.Println("Area of circle:", area)
}
Person Details:
Create a struct called Person with fields name and age. Write a program that creates an instance of Person and prints its details.
Solution:

go
Copy code
package main

import "fmt"

type Person struct {
    name string
    age  int
}

func main() {
    person := Person{name: "Alice", age: 25}
    fmt.Println("Name:", person.name)
    fmt.Println("Age:", person.age)
}
Swap Numbers:
Write a function that takes two integer parameters and swaps their values.
Solution:

go
Copy code
package main

import "fmt"

func swapNumbers(a, b *int) {
    *a, *b = *b, *a
}

func main() {
    x, y := 10, 20
    fmt.Println("Before swap - x:", x, "y:", y)
    swapNumbers(&x, &y)
    fmt.Println("After swap - x:", x, "y:", y)
}
Student Grade Average:
Create a struct called Student with fields name and grades, where grades is a slice of integers. Write a program that calculates and prints the average grade of a student.
Solution:

go
Copy code
package main

import "fmt"

type Student struct {
    name   string
    grades []int
}

func main() {
    student := Student{
        name:   "Alice",
        grades: []int{85, 92, 78, 90},
    }

    total := 0
    for _, grade := range student.grades {
        total += grade
    }
    average := float64(total) / float64(len(student.grades))
    fmt.Println("Average grade:", average)
}
Even Numbers:
Write a function that takes an integer slice and returns a new slice containing only the even numbers.
Solution:

go
Copy code
package main

import "fmt"

func evenNumbers(numbers []int) []int {
    even := make([]int, 0)

    for _, num := range numbers {
        if num%2 == 0 {
            even = append(even, num)
        }
    }

    return even
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    even := evenNumbers(numbers)
    fmt.Println("Even numbers:", even)
}

Certainly! Here are 10 simple coding challenges for learning Go syntax and structs, along with their solutions:

Create a Struct:
Create a struct called Person with fields name and age. Create an instance of Person and print its details.
Solution:

go
Copy code
package main

import "fmt"

type Person struct {
    name string
    age  int
}

func main() {
    person := Person{name: "Alice", age: 25}
    fmt.Println("Name:", person.name)
    fmt.Println("Age:", person.age)
}
Struct Method:
Create a struct called Rectangle with fields length and width. Add a method to Rectangle called calculateArea() that returns the area of the rectangle.
Solution:

go
Copy code
package main

import "fmt"

type Rectangle struct {
    length float64
    width  float64
}

func (r Rectangle) calculateArea() float64 {
    return r.length * r.width
}

func main() {
    rectangle := Rectangle{length: 4.5, width: 6.2}
    area := rectangle.calculateArea()
    fmt.Printf("Area of rectangle: %.2f\n", area)
}
Struct Initialization:
Create a struct called Car with fields brand and model. Initialize an instance of Car with the values "Toyota" for brand and "Corolla" for model.
Solution:

go
Copy code
package main

import "fmt"

type Car struct {
    brand string
    model string
}

func main() {
    car := Car{brand: "Toyota", model: "Corolla"}
    fmt.Println("Brand:", car.brand)
    fmt.Println("Model:", car.model)
}
Updating Struct Fields:
Create a struct called Person with fields name and age. Initialize an instance of Person with the values "John" for name and 30 for age. Update the age to 35 and print the updated details.
Solution:

go
Copy code
package main

import "fmt"

type Person struct {
    name string
    age  int
}

func main() {
    person := Person{name: "John", age: 30}
    fmt.Println("Name:", person.name)
    fmt.Println("Age:", person.age)

    // Update age
    person.age = 35

    fmt.Println("Updated Age:", person.age)
}
Nested Structs:
Create a struct called Address with fields street and city. Create a struct called Person with fields name and address, where address is of type Address. Initialize an instance of Person with appropriate values and print its details.
Solution:

go
Copy code
package main

import "fmt"

type Address struct {
    street string
    city   string
}

type Person struct {
    name    string
    address Address
}

func main() {
    address := Address{street: "123 Main St", city: "New York"}
    person := Person{name: "Alice", address: address}

    fmt.Println("Name:", person.name)
    fmt.Println("Street:", person.address.street)
    fmt.Println("City:", person.address.city)
}
Anonymous Struct:
Create an anonymous struct with fields name and age. Initialize an instance of the anonymous struct with appropriate values and print its details.
Solution:

go
Copy code
package main

import "fmt"

func main() {
    person := struct {
        name string
        age  int
    }{
        name: "Alice",
        age:  25,
    }

    fmt.Println("Name:", person.name)
	Rectangle Area:
Create a struct called Rectangle with two fields: width and height. Write a function called calculateArea that takes a Rectangle as input and returns the area of the rectangle.
go
Copy code
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func calculateArea(rectangle Rectangle) float64 {
    return rectangle.width * rectangle.height
}

func main() {
    rectangle := Rectangle{width: 4.5, height: 6.2}
    area := calculateArea(rectangle)
    fmt.Printf("Area of rectangle: %.2f\n", area)
}
Circle Area:
Create a struct called Circle with a field radius. Write a function called calculateArea that takes a Circle as input and returns the area of the circle.
go
Copy code
package main

import (
    "fmt"
    "math"
)

type Circle struct {
    radius float64
}

func calculateArea(circle Circle) float64 {
    return math.Pi * math.Pow(circle.radius, 2)
}

func main() {
    circle := Circle{radius: 3.7}
    area := calculateArea(circle)
    fmt.Printf("Area of circle: %.2f\n", area)
}
Student Grade Average:
Create a struct called Student with fields name, grades (an array of float64), and gradeCount (an integer representing the number of grades). Write a method called calculateAverageGrade for the Student struct that calculates and returns the average grade.
go
Copy code
package main

import "fmt"

type Student struct {
    name       string
    grades     []float64
    gradeCount int
}

func (s Student) calculateAverageGrade() float64 {
    total := 0.0
    for _, grade := range s.grades {
        total += grade
    }
    return total / float64(s.gradeCount)
}

func main() {
    student := Student{
        name:       "John",
        grades:     []float64{85.5, 92.0, 78.3, 90.7, 88.2},
        gradeCount: 5,
    }
    averageGrade := student.calculateAverageGrade()
    fmt.Printf("Average grade for %s: %.2f\n", student.name, averageGrade)
}